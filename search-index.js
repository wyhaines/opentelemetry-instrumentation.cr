crystal_doc_search_index_callback({"repository_name":"opentelemetry-instrumentation","body":"![OpenTelemetry CI](https://img.shields.io/github/workflow/status/wyhaines/opentelemetry-instrumentation.cr/OpenTelemetry%20Instrumentation%20CI?style=for-the-badge&logo=GitHub)\n[![GitHub release](https://img.shields.io/github/release/wyhaines/opentelemetry-instrumentation.cr.svg?style=for-the-badge)](https://github.com/wyhaines/opentelemetry-instrumentation.cr/releases)\n![GitHub commits since latest release (by SemVer)](https://img.shields.io/github/commits-since/wyhaines/opentelemetry-instrumentation.cr/latest?style=for-the-badge)\n\n# opentelemetry-instrumentation\n\nThis package provides both the base functionality needed to build instrumentation for arbitrary classes/libraries, but also ready-made instrumentation for commonly used Crystal libraries.\n\n## Installation\n\n1. Add the dependency to your `shard.yml`:\n\n   ```yaml\n   dependencies:\n     opentelemetry-instrumentation:\n       github: wyhaines/opentelemetry-instrumentation.cr\n   ```\n\n2. Run `shards install`\n\n## Usage\n\n```crystal\nrequire \"opentelemetry-instrumentation.cr\"\n```\n\nRequiring the top level library will attempt to instrument, via a `macro finished` block, every component within your project for which there exists instrumentation. Each instrumentation package attempts to determine whether it is safe to install before doing so, by validating that required components are installed, and that their versions are compatible.\n\nThe reason for running the autoinstrumentation within a `finished` block is to ensure that all other classes have been loaded prior to loading the instrumentation. However, the structure of some softare and frameworks (such as [https://luckyframework.org/](https://luckyframework.org/)) prevent this from working properly. If it appears that instrumentation has not been installed, you can check what instruments have been installed by examining the data returned from `OpenTelemetry::Instrumentation::Registry.instruments`. It may look like this:\n\n```crystal\n[OpenTelemetry::Instrumentation::CrystalDB,\nOpenTelemetry::Instrumentation::CrystalHttpServer,\nOpenTelemetry::Instrumentation::CrystalLog]\n\n```\n\nIf the array is empty, then no instrumentation was installed. You can require instrumentation manually by requiring the relevant file. For instance, to manually install the DB instrumentation (assuming that DB has been previously required):\n\n```crystal\nrequire \"opentelemetry-instrumentation/src/instrumentation/crystal/db\"\n```\n\n## Documentation\n\nThe generated docs can all be found here:\n\n[https://wyhaines.github.io/opentelemetry-instrumentation.cr/](https://wyhaines.github.io/opentelemetry-instrumentation.cr/)\n\n## Contributing\n\n1. Fork it (<https://github.com/wyhaines/opentelemetry-instrumentation.cr/fork>)\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Commit your changes (`git commit -am 'Add some feature'`)\n4. Push to the branch (`git push origin my-new-feature`)\n5. Create a new Pull Request\n\n## Contributors\n\n- [Kirk Haines](https://github.com/wyhaines) - creator and maintainer\n\n![GitHub code size in bytes](https://img.shields.io/github/languages/code-size/wyhaines/opentelemetry-instrumentation.cr?style=for-the-badge)\n![GitHub issues](https://img.shields.io/github/issues/wyhaines/opentelemetry-instrumentation.cr?style=for-the-badge)\n","program":{"html_id":"opentelemetry-instrumentation/toplevel","path":"toplevel.html","kind":"module","full_name":"Top Level Namespace","name":"Top Level Namespace","abstract":false,"locations":[],"repository_name":"opentelemetry-instrumentation","program":true,"enum":false,"alias":false,"const":false,"types":[{"html_id":"opentelemetry-instrumentation/Log","path":"Log.html","kind":"class","full_name":"Log","name":"Log","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":69,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"doc":"The `Log` class provides a logging utility that you can use to output messages.\n\nThe messages, or `Log::Entry` have associated levels, such as `Info` or `Error`\nthat indicate their importance. See `Log::Severity`.\n\nTo log a message `trace`, `debug`, `info`, `notice`, `warn`, `error`, and `fatal` methods\ncan be used. They expect a block that will evaluate to the message of the entry.\n\n```\nrequire \"log\"\n\nLog.info { \"Program started\" }\n```\n\nData can be associated with a log entry via the `Log::Emitter` yielded in the logging methods.\n\n```\nLog.info &.emit(\"User logged in\", user_id: 42)\n```\n\nIf you want to log an exception, you can indicate it in the `exception:` named argument.\n\n```\nLog.warn(exception: e) { \"Oh no!\" }\nLog.warn exception: e, &.emit(\"Oh no!\", user_id: 42)\n```\n\nThe block is only evaluated if the current message is to be emitted to some `Log::Backend`.\n\nTo add structured information to the message you can use the `Log::Context`.\n\nWhen creating log messages they belong to a _source_. If the top-level `Log` is used\nas in the above examples its source is the empty string.\n\nThe source can be used to identify the module or part of the application that is logging.\nYou can configure for each source a different level to filter the messages.\n\nA recommended pattern is to declare a `Log` constant in the namespace of your shard or module as follows:\n\n```\nmodule DB\n  Log = ::Log.for(\"db\") # => Log for db source\n\n  def do_something\n    Log.info { \"this is logged in db source\" }\n  end\nend\n\nDB::Log.info { \"this is also logged in db source\" }\nLog.for(\"db\").info { \"this is also logged in db source\" }\nLog.info { \"this is logged in top-level source\" }\n```\n\nThat way, any `Log.info` call within the `DB` module will use the `db` source. And not the top-level `::Log.info`.\n\nSources can be nested. Continuing the last example, to declare a `Log` constant `db.pool` source you can do as follows:\n\n```\nclass DB::Pool\n  Log = DB::Log.for(\"pool\") # => Log for db.pool source\nend\n```\n\nA `Log` will emit the messages to the `Log::Backend`s attached to it as long as\nthe configured severity filter `level` permits it.\n\nLogs can also be created from a type directly. For the type `DB::Pool` the source `db.pool` will be used.\nFor generic types as `Foo::Bar(Baz)` the source `foo.bar` will be used (i.e. without generic arguments).\n\n```\nmodule DB\n  Log = ::Log.for(self) # => Log for db source\nend\n```\n\n### Default logging configuration\n\nBy default entries from all sources with `Info` and above severity will\nbe logged to `STDOUT` using the `Log::IOBackend`.\n\nIf you need to change the default level, backend or sources call `Log.setup` upon startup.\n\nNOTE: Calling `setup` will override previous `setup` calls.\n\n```\nLog.setup(:debug)                     # Log debug and above for all sources to STDOUT\nLog.setup(\"myapp.*, http.*\", :notice) # Log notice and above for myapp.* and http.* sources only, and log nothing for any other source.\nbackend_with_formatter = Log::IOBackend.new(formatter: custom_formatter)\nLog.setup(:debug, backend_with_formatter) # Log debug and above for all sources to using a custom backend\n```\n\n### Configure logging explicitly in the code\n\nUse `Log.setup` methods to indicate which sources should go to which backends.\n\nYou can indicate actual sources or patterns.\n\n* the empty string matches only the top-level source\n* `*` matches all the sources\n* `foo.bar.*` matches `foo.bar` and every nested source\n* `foo.bar` matches `foo.bar`, but not its nested sources\n* Any comma separated combination of the above\n\nThe following configuration will setup for all sources to emit\nwarnings (or higher) to `STDOUT`, allow any of the `db.*` and\nnested source to emit debug (or higher), and to also emit for all\nsources errors (or higher) to an elasticsearch backend.\n\n```\nLog.setup do |c|\n  backend = Log::IOBackend.new\n\n  c.bind \"*\", :warn, backend\n  c.bind \"db.*\", :debug, backend\n  c.bind \"*\", :error, ElasticSearchBackend.new(\"http://localhost:9200\")\nend\n```\n\n### Configure logging from environment variables\n\nInclude the following line to allow configuration from environment variables.\n\n```\nLog.setup_from_env\n```\n\nThe environment variable `LOG_LEVEL` is used to indicate which severity level to emit.\nBy default entries from all sources with `Info` and above severity will\nbe logged to `STDOUT` using the `Log::IOBackend`.\n\nTo change the level and sources change the environment variable value:\n\n```console\n$ LOG_LEVEL=DEBUG ./bin/app\n```\n\nYou can tweak the default values (used when `LOG_LEVEL` variable is not defined):\n\n```\nLog.setup_from_env(default_level: :error)\n```\n","summary":"<p>The <code><a href=\"Log.html\">Log</a></code> class provides a logging utility that you can use to output messages.</p>","instance_methods":[{"html_id":"debug(*,exception:Exception?=nil,&)-instance-method","name":"debug","doc":"Logs a message if the logger's current severity is lower or equal to `1`.","summary":"<p>Logs a message if the logger's current severity is lower or equal to <code>1</code>.</p>","abstract":false,"args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = nil, &)","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &)","location":{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":70,"url":null},"def":{"name":"debug","args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"splat_index":0,"yields":1,"visibility":"Public","body":"severity = Severity.new(1)\nif (span = OpenTelemetry::Trace.current_span) && level <= severity\n  dsl = Emitter.new(@source, severity, exception)\n  result = yield dsl\n  entry = case result\n  when Entry\n    result\n  else\n    dsl.emit(result.to_s)\n  end\n  backend = @backend\n  span.add_event(\"Log.#{entry.severity.label}#{if entry.source.empty?\n  else\n    \" - #{entry.source}\"\n  end}\") do |event|\n    OpenTelemetry::Instrumentation::LogBackend.apply_log_entry(entry, event)\n  end\n  if backend\n  else\n    return\n  end\n  backend.dispatch(entry)\nelse\n  previous_def(exception: exception) do |e|\n    yield e\n  end\nend\n"}},{"html_id":"error(*,exception:Exception?=nil,&)-instance-method","name":"error","doc":"Logs a message if the logger's current severity is lower or equal to `5`.","summary":"<p>Logs a message if the logger's current severity is lower or equal to <code>5</code>.</p>","abstract":false,"args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = nil, &)","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &)","location":{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":70,"url":null},"def":{"name":"error","args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"splat_index":0,"yields":1,"visibility":"Public","body":"severity = Severity.new(5)\nif (span = OpenTelemetry::Trace.current_span) && level <= severity\n  dsl = Emitter.new(@source, severity, exception)\n  result = yield dsl\n  entry = case result\n  when Entry\n    result\n  else\n    dsl.emit(result.to_s)\n  end\n  backend = @backend\n  span.add_event(\"Log.#{entry.severity.label}#{if entry.source.empty?\n  else\n    \" - #{entry.source}\"\n  end}\") do |event|\n    OpenTelemetry::Instrumentation::LogBackend.apply_log_entry(entry, event)\n  end\n  if backend\n  else\n    return\n  end\n  backend.dispatch(entry)\nelse\n  previous_def(exception: exception) do |e|\n    yield e\n  end\nend\n"}},{"html_id":"fatal(*,exception:Exception?=nil,&)-instance-method","name":"fatal","doc":"Logs a message if the logger's current severity is lower or equal to `6`.","summary":"<p>Logs a message if the logger's current severity is lower or equal to <code>6</code>.</p>","abstract":false,"args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = nil, &)","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &)","location":{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":70,"url":null},"def":{"name":"fatal","args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"splat_index":0,"yields":1,"visibility":"Public","body":"severity = Severity.new(6)\nif (span = OpenTelemetry::Trace.current_span) && level <= severity\n  dsl = Emitter.new(@source, severity, exception)\n  result = yield dsl\n  entry = case result\n  when Entry\n    result\n  else\n    dsl.emit(result.to_s)\n  end\n  backend = @backend\n  span.add_event(\"Log.#{entry.severity.label}#{if entry.source.empty?\n  else\n    \" - #{entry.source}\"\n  end}\") do |event|\n    OpenTelemetry::Instrumentation::LogBackend.apply_log_entry(entry, event)\n  end\n  if backend\n  else\n    return\n  end\n  backend.dispatch(entry)\nelse\n  previous_def(exception: exception) do |e|\n    yield e\n  end\nend\n"}},{"html_id":"info(*,exception:Exception?=nil,&)-instance-method","name":"info","doc":"Logs a message if the logger's current severity is lower or equal to `2`.","summary":"<p>Logs a message if the logger's current severity is lower or equal to <code>2</code>.</p>","abstract":false,"args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = nil, &)","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &)","location":{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":70,"url":null},"def":{"name":"info","args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"splat_index":0,"yields":1,"visibility":"Public","body":"severity = Severity.new(2)\nif (span = OpenTelemetry::Trace.current_span) && level <= severity\n  dsl = Emitter.new(@source, severity, exception)\n  result = yield dsl\n  entry = case result\n  when Entry\n    result\n  else\n    dsl.emit(result.to_s)\n  end\n  backend = @backend\n  span.add_event(\"Log.#{entry.severity.label}#{if entry.source.empty?\n  else\n    \" - #{entry.source}\"\n  end}\") do |event|\n    OpenTelemetry::Instrumentation::LogBackend.apply_log_entry(entry, event)\n  end\n  if backend\n  else\n    return\n  end\n  backend.dispatch(entry)\nelse\n  previous_def(exception: exception) do |e|\n    yield e\n  end\nend\n"}},{"html_id":"notice(*,exception:Exception?=nil,&)-instance-method","name":"notice","doc":"Logs a message if the logger's current severity is lower or equal to `3`.","summary":"<p>Logs a message if the logger's current severity is lower or equal to <code>3</code>.</p>","abstract":false,"args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = nil, &)","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &)","location":{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":70,"url":null},"def":{"name":"notice","args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"splat_index":0,"yields":1,"visibility":"Public","body":"severity = Severity.new(3)\nif (span = OpenTelemetry::Trace.current_span) && level <= severity\n  dsl = Emitter.new(@source, severity, exception)\n  result = yield dsl\n  entry = case result\n  when Entry\n    result\n  else\n    dsl.emit(result.to_s)\n  end\n  backend = @backend\n  span.add_event(\"Log.#{entry.severity.label}#{if entry.source.empty?\n  else\n    \" - #{entry.source}\"\n  end}\") do |event|\n    OpenTelemetry::Instrumentation::LogBackend.apply_log_entry(entry, event)\n  end\n  if backend\n  else\n    return\n  end\n  backend.dispatch(entry)\nelse\n  previous_def(exception: exception) do |e|\n    yield e\n  end\nend\n"}},{"html_id":"trace(*,exception:Exception?=nil,&)-instance-method","name":"trace","doc":"Logs a message if the logger's current severity is lower or equal to `0`.","summary":"<p>Logs a message if the logger's current severity is lower or equal to <code>0</code>.</p>","abstract":false,"args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = nil, &)","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &)","location":{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":70,"url":null},"def":{"name":"trace","args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"splat_index":0,"yields":1,"visibility":"Public","body":"severity = Severity.new(0)\nif (span = OpenTelemetry::Trace.current_span) && level <= severity\n  dsl = Emitter.new(@source, severity, exception)\n  result = yield dsl\n  entry = case result\n  when Entry\n    result\n  else\n    dsl.emit(result.to_s)\n  end\n  backend = @backend\n  span.add_event(\"Log.#{entry.severity.label}#{if entry.source.empty?\n  else\n    \" - #{entry.source}\"\n  end}\") do |event|\n    OpenTelemetry::Instrumentation::LogBackend.apply_log_entry(entry, event)\n  end\n  if backend\n  else\n    return\n  end\n  backend.dispatch(entry)\nelse\n  previous_def(exception: exception) do |e|\n    yield e\n  end\nend\n"}},{"html_id":"warn(*,exception:Exception?=nil,&)-instance-method","name":"warn","doc":"Logs a message if the logger's current severity is lower or equal to `4`.","summary":"<p>Logs a message if the logger's current severity is lower or equal to <code>4</code>.</p>","abstract":false,"args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"args_string":"(*, exception : Exception? = nil, &)","args_html":"(*, exception : Exception? = <span class=\"n\">nil</span>, &)","location":{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":70,"url":null},"def":{"name":"warn","args":[{"name":"","external_name":"","restriction":""},{"name":"exception","default_value":"nil","external_name":"exception","restriction":"Exception | ::Nil"}],"splat_index":0,"yields":1,"visibility":"Public","body":"severity = Severity.new(4)\nif (span = OpenTelemetry::Trace.current_span) && level <= severity\n  dsl = Emitter.new(@source, severity, exception)\n  result = yield dsl\n  entry = case result\n  when Entry\n    result\n  else\n    dsl.emit(result.to_s)\n  end\n  backend = @backend\n  span.add_event(\"Log.#{entry.severity.label}#{if entry.source.empty?\n  else\n    \" - #{entry.source}\"\n  end}\") do |event|\n    OpenTelemetry::Instrumentation::LogBackend.apply_log_entry(entry, event)\n  end\n  if backend\n  else\n    return\n  end\n  backend.dispatch(entry)\nelse\n  previous_def(exception: exception) do |e|\n    yield e\n  end\nend\n"}}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry","path":"OpenTelemetry.html","kind":"module","full_name":"OpenTelemetry","name":"OpenTelemetry","abstract":false,"locations":[{"filename":"lib/opentelemetry-api/src/exporter.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/exporters/abstract.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/exporters/base.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/exporters/buffered_base.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/exporters/buffered_exporter.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/exporters/http.cr","line_number":23,"url":null},{"filename":"lib/opentelemetry-api/src/exporters/io.cr","line_number":4,"url":null},{"filename":"lib/opentelemetry-api/src/exporters/null.cr","line_number":4,"url":null},{"filename":"lib/opentelemetry-api/src/exporters/stdout.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/exporters/unbuffered_exporter.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api.cr","line_number":72,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/aliases.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/anyvalue.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/attribute.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/context.cr","line_number":4,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/context/key.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/event.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/id_generator.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/id_generator/base.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/id_generator/random.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/id_generator/unique.cr","line_number":6,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/instrument.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/instrument.cr","line_number":53,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/instrument/counter.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/log.cr","line_number":6,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/log_collection.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/log_provider.cr","line_number":5,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/meter.cr","line_number":4,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/meter/exceptions.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/meter_provider.cr","line_number":4,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/name.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/propagation/text_map_getter.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/propagation/text_map_setter.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/propagation/trace_context.cr","line_number":6,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/propagation/trace_context/trace_parent.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/provider.cr","line_number":5,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/provider/configuration.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/provider/configuration/factory.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/resource.cr","line_number":4,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/sendable.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/span.cr","line_number":8,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/span/kind.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/span_context.cr","line_number":3,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/status.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/text_map_propagator.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/trace.cr","line_number":8,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/trace/exceptions.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/trace_flags.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/trace_provider.cr","line_number":4,"url":null},{"filename":"lib/opentelemetry-api/src/opentelemetry-api/version.cr","line_number":1,"url":null},{"filename":"lib/opentelemetry-api/src/proto/common.pb.cr","line_number":4,"url":null},{"filename":"lib/opentelemetry-api/src/proto/logs.pb.cr","line_number":7,"url":null},{"filename":"lib/opentelemetry-api/src/proto/logs_service.pb.cr","line_number":6,"url":null},{"filename":"lib/opentelemetry-api/src/proto/resource.pb.cr","line_number":6,"url":null},{"filename":"lib/opentelemetry-api/src/proto/trace.pb.cr","line_number":7,"url":null},{"filename":"lib/opentelemetry-api/src/proto/trace_service.pb.cr","line_number":6,"url":null},{"filename":"src/opentelemetry/instrumentation/instrument.cr","line_number":4,"url":null},{"filename":"src/opentelemetry/instrumentation/registry.cr","line_number":3,"url":null},{"filename":"src/opentelemetry/instrumentation/version.cr","line_number":1,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"doc":"```\n\n## Global Trace Provider\n----------------------------------------------------------------\n\nOpenTelemetry.configure do |config|\n  config.service_name = \"my_app_or_library\"\n  config.service_version = \"1.1.1\"\n  config.exporter = OpenTelemetry::IOExporter.new(:STDOUT)\nend\n\ntrace = OpenTelemetry.trace_provider(\"my_app_or_library\", \"1.1.1\")\ntrace = OpenTelemetry.trace_provider do |provider|\n  provider.service_name = \"my_app_or_library\"\n  provider.service_version = \"1.1.1\"\nend.trace\n\n## Trace Providers as Objects With Unique Configuration\n----------------------------------------------------------------\n\nprovider_a = OpenTelemetry::TraceProvider.new(\"my_app_or_library\", \"1.1.1\")\nprovider_a.exporter = OpenTelemetry::IOExporter.new(:STDOUT)\n\nprovider_b = OpenTelementry::TraceProvider.new do |config|\n  config.service_name = \"my_app_or_library\"\n  config.service_version = \"1.1.1\"\n  config.exporter = OpenTelemetry::IOExporter.new(:STDOUT)\nend\n\n## Getting a Trace From a Provider Object\n----------------------------------------------------------------\n\ntrace = provider_a.trace # Inherit all configuration from the Provider Object\n\ntrace = provider_a.trace(\"microservice foo\", \"1.2.3\") # Override the configuration\n\ntrace = provider_a.trace do |provider|\n  provider.service_name = \"microservice foo\"\n  provider.service_version = \"1.2.3\"\nend.trace\n\n## Creating Spans Using a Trace\n----------------------------------------------------------------\n\ntrace.in_span(\"request\") do |span|\n  span.set_attribute(\"verb\", \"GET\")\n  span.set_attribute(\"url\", \"http://example.com/foo\")\n  span.add_event(\"dispatching to handler\")\n  trace.in_span(\"handler\") do |child_span|\n    child_span.add_event(\"handling request\")\n    trace.in_span(\"db\") do |child_span|\n      child_span.add_event(\"querying database\")\n    end\n  end\nend","summary":"<pre><code class=\"language-crystal\"></code></pre>","types":[{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","path":"OpenTelemetry/InstrumentationDocumentation.html","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation","abstract":false,"locations":[{"filename":"src/opentelemetry/instrumentation/crystal/db.cr","line_number":30,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry","kind":"module","full_name":"OpenTelemetry","name":"OpenTelemetry"},"types":[{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/CrystalDB","path":"OpenTelemetry/InstrumentationDocumentation/CrystalDB.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::CrystalDB","name":"CrystalDB","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/crystal/db.cr","line_number":30,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation"},"doc":"# OpenTelemetry::Instrumentation::CrystalDB\n\n### Instruments\n\n  * DB::Statement\n\n### Reference: [http://crystal-lang.github.io/crystal-db/api/latest/DB.html](http://crystal-lang.github.io/crystal-db/api/latest/DB.html)\n\nThis instrumentation will trace any database interactions that subclass from the Crystal standard `DB` class/shard.\n\n## Methods Affected\n\nNo methods are being overridden. The DB package provides a built-in way of wrapping queries, via\nthe `DB::Statement#def_around_query_or_exec` macro. This functionality simply leverages that.\n\n[http://crystal-lang.github.io/crystal-db/api/latest/DB/Statement.html](http://crystal-lang.github.io/crystal-db/api/latest/DB/Statement.html#def_around_query_or_exec%28%26block%29-macro)\n\n## Configuration\n\n- `OTEL_CRYSTAL_DISABLE_INSTRUMENTATION_DB`\n\n  If set, this will **disable** the `DB` instrumentation.\n\n## Version Restrictions\n\n* DB >= 0.10.0\n","summary":"<h1><a id=\"open-telemetryinstrumentationcrystal-db\" class=\"anchor\" href=\"#open-telemetryinstrumentationcrystal-db\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::CrystalDB</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/db.cr","line_number":30,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/db.cr","line_number":30,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/CrystalGC","path":"OpenTelemetry/InstrumentationDocumentation/CrystalGC.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::CrystalGC","name":"CrystalGC","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/crystal/gc.cr","line_number":45,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation"},"doc":"\n# OpenTelemetry::Instrumentation::CrystalGC\n\n### Instruments\n\n  * GC\n\n### Reference: [https://crystal-lang.org/api/1.4.1/GC.html](https://crystal-lang.org/api/1.4.1/GC.html)\n\nTo instrument garbage collection, the ideal world would be to have something that could record a timestamp\nbefore the GC cycle runs, and then trigger an action after it completes which would create a span, using the\nprerecorded GC start timestamp.\n\nRight now I know of no way to do this. So the next best option is what we have implemented here. This\ninstrument creates a fiber that spends most of its life sleeping. One a regular interval, which defaults to\n300 seconds, it will wake, gather current GC stats, and create a span to record those. If there is a currently\nactive trace, the span will be injected into that trace. Otherwise, it will be a standalone trace.\n\nTODO: If the API adds a mechanism for creating what is essentially a trace future, this will be changed so that\nit can, based on a config setting, use that. This will let people choose to have GC spans _always_ exist only\nin their own traces, which is probably what makes the most sense in a world where we can't hook directly into\nthe GC cycle.\n\n## Configuration\n\n- `OTEL_CRYSTAL_DISABLE_INSTRUMENTATION_GC`\n\n  If set, this will **disable** the garbage collection instrumentation.\n\n- `OTEL_CRYSTAL_GC_SPAN_RECORDING_INTERVAL`\n\n  If set, this is expected to be a positive integer which specifies the number of seconds in between reporting\n  intervals for GC stats. If not set, defaults to 300 seconds.\n\n## Version Restrictions\n\n* Crystal >= 1.0.0\n\n## Methods Affected\n\n- NONE\n","summary":"<h1><a id=\"open-telemetryinstrumentationcrystal-gc\" class=\"anchor\" href=\"#open-telemetryinstrumentationcrystal-gc\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::CrystalGC</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/gc.cr","line_number":45,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/gc.cr","line_number":45,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/CrystalHttpClient","path":"OpenTelemetry/InstrumentationDocumentation/CrystalHttpClient.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::CrystalHttpClient","name":"CrystalHttpClient","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/crystal/http_client.cr","line_number":42,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation"},"doc":"# OpenTelemetry::Instrumentation::CrystalHttpClient\n\n### Instruments\n\n  * HTTP::Client\n\n### Reference: [https://crystal-lang.org/api/1.4.1/HTTP/Client.html](https://crystal-lang.org/api/1.4.1/HTTP/Client.html)\n\nThe HTTP::Client auto-instrumentation redefactirs the `HTTP::Client#io` method from a large method to a very small one,\nand moves most of the work into two new methods, `HTTP::Client#do_connect` and `HTTP::Client#do_connect_ssl`, which can\nthen be instrumented, and can receive some additional code to capture some information which is normally discarded, but\nwhich the semantic conventions for HTTP spans calls for. It then uses a `#def_around_exec` block to complete the instrumentation.\n\n## Configuration\n\n- `OTEL_CRYSTAL_DISABLE_INSTRUMENTATION_HTTP_CLIENT`\n\n  If set, this will **disable** the instrumentation.\n\n## Version Restrictions\n\n* Crystal >= 1.0.0\n\n## Methods Affected\n\n- `HTTP::Client.io`\n\n  Refactored from a large method to a small method that calls `#do_connect`.\n\n- `HTTP::Client#do_connect`\n\n  Capture some information about the connection that is thrown away in the original method,\n  and the utilize it in the instrumentation wrapper that follows.\n\n- `HTTP::Client#do_connect_ssl`\n\n  Capture some information about the connection that is thrown away in the original method,\n  and the utilize it in the instrumentation wrapper that follows.\n","summary":"<h1><a id=\"open-telemetryinstrumentationcrystal-http-client\" class=\"anchor\" href=\"#open-telemetryinstrumentationcrystal-http-client\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::CrystalHttpClient</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/http_client.cr","line_number":42,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/http_client.cr","line_number":42,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/CrystalHttpServer","path":"OpenTelemetry/InstrumentationDocumentation/CrystalHttpServer.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::CrystalHttpServer","name":"CrystalHttpServer","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/crystal/http_server.cr","line_number":35,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation"},"doc":"# OpenTelemetry::Instrumentation::CrystalHttpServer\n\n### Instruments:\n\n  * HTTP::Server\n  * HTTP::Handler\n  * HTTP::RequestProcessor\n\n### Reference: [https://crystal-lang.org/api/latest/HTTP/Server.html](https://crystal-lang.org/api/latest/HTTP/Server.html)\n\nThe **HTTP::Server** implementation, provided in the Crystal standard library, is utilized by\nmost Crystal web frameworks. It provides a simple HTTP 1.x compliant server that applications\ncan use to receive requests and to issue responses.\n\nThe OpenTelemetry instrumentation of **HTTP::Server** will generate traces for each request, from\nthe start to the end of it's handling.\n\n## Configuration\n\n- `OTEL_CRYSTAL_DISABLE_INSTRUMENTATION_HTTP_SERVER`\n\n  If set, this will **disable** the `HTTP::WebServer` instrumentation.\n\n## Version Restrictions\n\n* Crystal >= 1.0.0\n\n## Methods Affected\n\n* HTTP::Server#handle_client\n* HTTP::Handler#call_next\n* HTTP::RequestProcessor#process","summary":"<h1><a id=\"open-telemetryinstrumentationcrystal-http-server\" class=\"anchor\" href=\"#open-telemetryinstrumentationcrystal-http-server\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::CrystalHttpServer</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/http_server.cr","line_number":35,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/http_server.cr","line_number":35,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/CrystalHttpWebSocket","path":"OpenTelemetry/InstrumentationDocumentation/CrystalHttpWebSocket.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::CrystalHttpWebSocket","name":"CrystalHttpWebSocket","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/crystal/http_websocket.cr","line_number":82,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation"},"doc":"# OpenTelemetry::Instrumentation::CrystalHttpWebSocket\n\n### Instruments\n\n  * HTTP::WebSocket\n\n### Reference: [https://crystal-lang.org/api/1.4.0/HTTP/WebSocket.html](https://crystal-lang.org/api/1.4.0/HTTP/WebSocket.html)\n\nThis instrumentation package instruments both client and server use of HTTP::WebSocket. As of 0.3.0 of\nof `OpenTelemetry::Instrumentation`, the package first monkey patches HTTP::WebSocket to rewrite it into a\nrefactored version that reduces the [cyclomatic complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity)\nof the `#run` method while also making it easier to inject tracing. Those refactors are being presented back\nto the main Crystal project as a proposed PR, and if they are accepted, a large chunk of the code in this\ninstrumentation package can be removed.\n\nThe remaining instrumentation wraps the client methods, `#send`, `#ping`, `#pong`, `#stream`, and `#close`,\nas well as the refactored handler methods that `#run` depends on, `#handle_ping`, `#handle_pong`, `#handle_text`,\n`#handle_binary`, `#handle_close`, and `#handle_continuation`.\n\n## Configuration\n\n- `OTEL_CRYSTAL_DISABLE_INSTRUMENTATION_HTTP_WEBSOCKET`\n\n  If set, this will **disable** the `HTTP::WebSocket` instrumentation.\n\n## Version Restrictions\n\n* Crystal >= 1.0.0\n\n## Methods Affected\n\n- `HTTP::WebSocket#run`\n\n  This method is refactored from the original while retaining identical functionality.\n\n- `HTTP::WebSocket#send`\n\n  Wrap a `#send` call in a *client* type span.\n\n- `HTTP::WebSocket#ping`\n\n  Wrap a `#ping` call in a *client* type span.\n\n- `HTTP::WebSocket#pong`\n\n  Wrap a `#pong` call in a *client* type span.\n\n- `HTTP::WebSocket#stream`\n\n  Wrap a `#stream` call in a *client* type span.\n\n- `HTTP::WebSocket#close`\n\n  Wrap a `#close` call in a *client* type span.\n\n- `HTTP::WebSocket#handle_ping`\n\n  Wrap a `#handle_ping` call in a *server* type span, with the message attached as an attribute.\n\n- `HTTP::WebSocket#handle_pong`\n\n  Wrap a `#handle_pong` call in a *server* type span, with the message attached as an attribute.\n\n- `HTTP::WebSocket#handle_text`\n\n  Wrap a `#handle_text` call in a *server* type span, with the message attached as an attribute.\n\n- `HTTP::WebSocket#handle_binary`\n\n  Wrap a `#handle_binary` call in a *server* type span, with the message attached as an attribute.\n\n- `HTTP::WebSocket#handle_close`\n\n  Wrap a `#handle_close` call in a *server* type span, with the close-code and the message attached as an attribute.\n\n- `HTTP::WebSocket#handle_continuation`\n\n  Wrap a `#handle_continuation` call in a *server* type span.\n","summary":"<h1><a id=\"open-telemetryinstrumentationcrystal-http-web-socket\" class=\"anchor\" href=\"#open-telemetryinstrumentationcrystal-http-web-socket\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::CrystalHttpWebSocket</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/http_websocket.cr","line_number":82,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/http_websocket.cr","line_number":82,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/CrystalLog","path":"OpenTelemetry/InstrumentationDocumentation/CrystalLog.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::CrystalLog","name":"CrystalLog","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":55,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation"},"doc":"# OpenTelemetry::Instrumentation::CrystalLog\n\n### Instruments\n\n  * Log\n\n### Reference: [https://crystal-lang.org/api/1.4.0/Log.html](https://crystal-lang.org/api/1.4.0/Log.html)\n\nThis instrument will record logs generated with `Log` as events in the current span. If there\nis no current span, the instrument is a NOP. In either case, configured logging then procedes\nas expected.\n\n## Configuration\n\n- `OTEL_CRYSTAL_DISABLE_INSTRUMENTATION_LOG`\n\n  If set, this will **disable** the `Log` instrumentation.\n\n## Version Restrictions\n\n* Crystal >= 1.0.0\n\n## Methods Affected\n\n- `Log#trace`\n\n  Attach the trace log event to the current span.\n\n- `Log#debug`\n\n  Attach the debug log event to the current span.\n\n- `Log#info`\n\n  Attach the info log event to the current span.\n\n- `Log#notice`\n\n  Attach the notice log event to the current span.\n\n- `Log#warn`\n\n  Attach the warn log event to the current span.\n\n- `Log#error`\n\n  Attach the error log event to the current span.\n\n- `Log#fatal`\n\n  Attach the fatal log event to the current span.\n","summary":"<h1><a id=\"open-telemetryinstrumentationcrystal-log\" class=\"anchor\" href=\"#open-telemetryinstrumentationcrystal-log\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::CrystalLog</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":55,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/crystal/log.cr","line_number":55,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/Framework","path":"OpenTelemetry/InstrumentationDocumentation/Framework.html","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation::Framework","name":"Framework","abstract":false,"locations":[{"filename":"src/opentelemetry/instrumentation/frameworks/lucky.cr","line_number":46,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation"},"types":[{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/Framework/Lucky","path":"OpenTelemetry/InstrumentationDocumentation/Framework/Lucky.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::Framework::Lucky","name":"Lucky","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/frameworks/lucky.cr","line_number":46,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/Framework","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation::Framework","name":"Framework"},"doc":"# OpenTelemetry::Instrumentation::FrameWork::Lucky\n\n### Instruments\n  * Lucky::RouteHandler\n\n### Reference: [https://luckyframework.github.io/lucky/Lucky/RouteHandler.html](https://luckyframework.github.io/lucky/Lucky/RouteHandler.html)\n\nAutoinstrumentation for Lucky is pretty minimal. Other core instrumentation handles most of\nthe heavy lifting. This instrumentation package supplements that work my adding the *http.route*\nattribute to the RouteHandler span, if there is a route to be added.\n\nTo instrument a Lucky application, add the following requires to your *src/start_server.cr* file:\n\n```\nrequire \"opentelemetry-instrumentation\"\nrequire \"opentelemetry-instrumentation/src/opentelemetry/instrumentation/**\"\n```\n\nAfter adding that, add a stanza to do some basic configuration of the OpenTelemetry framework:\n\n```\nOpenTelemetry.configure do |config|\n  config.service_name = \"My Lucky App\"\n  config.service_version = \"1.0.0\"\n  config.exporter = OpenTelemetry::Exporter.new(variant: :http) do |exporter|\n    exporter = exporter.as(OpenTelemetry::Exporter::Http)\n    exporter.endpoint = \"https://otlp.nr-data.net:4318/v1/traces\"\n    headers = HTTP::Headers.new\n    headers[\"api-key\"] = ENV[\"NEW_RELIC_LICENSE_KEY\"]?.to_s\n    exporter.headers = headers\n  end\nend\n```\n\nThat is all that you should need to do. If your environment has an appropriate license key\nin the *NEW_RELIC_LICENSE_KEY* environment variable, the OpenTelemetry exporter will send\nthe traces to New Relic. A similar setup should work with any provider that supports OTLP/HTTP\ningest of OpenTelemetry.\n\n## Methods Affected\n\n* Lucky::RouteHandler#call\n","summary":"<h1><a id=\"open-telemetryinstrumentationframe-worklucky\" class=\"anchor\" href=\"#open-telemetryinstrumentationframe-worklucky\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::FrameWork::Lucky</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/frameworks/lucky.cr","line_number":46,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/frameworks/lucky.cr","line_number":46,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/Framework/SpiderGazelle","path":"OpenTelemetry/InstrumentationDocumentation/Framework/SpiderGazelle.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::Framework::SpiderGazelle","name":"SpiderGazelle","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/frameworks/spider-gazelle.cr","line_number":47,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/Framework","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation::Framework","name":"Framework"},"doc":"# OpenTelemetry::Instrumentation::FrameWork::SpiderGazelle\n\n### Instruments\n  * ActionController::Router::RouteHandler\n\n### Reference: [action-controller/router/route_handler.cr](https://github.com/spider-gazelle/action-controller/blob/master/src/action-controller/router/route_handler.cr)\n\nAutoinstrumentation for Spider-Gazelle is pretty minimal. Other core instrumentation handles most of\nthe heavy lifting. This instrumentation package supplements that work by adding the *http.route*\nattribute to the RouteHandler span, if there is a route to be added.\n\nTo instrument a Spider-Gazelle application, add the following requires to your *src/config.cr* file:\n\n```\nrequire \"action-controller\"\nrequire \"opentelemetry-instrumentation\"\nrequire \"opentelemetry-instrumentation/src/opentelemetry/instrumentation/**\"\n```\n\nAfter adding that, add a stanza to do some basic configuration of the OpenTelemetry framework:\n\n```\nOpenTelemetry.configure do |config|\n  config.service_name = \"My Spider-Gazelle App\"\n  config.service_version = \"1.0.0\"\n  config.exporter = OpenTelemetry::Exporter.new(variant: :http) do |exporter|\n    exporter = exporter.as(OpenTelemetry::Exporter::Http)\n    exporter.endpoint = \"https://otlp.nr-data.net:4318/v1/traces\"\n    headers = HTTP::Headers.new\n    headers[\"api-key\"] = ENV[\"NEW_RELIC_LICENSE_KEY\"]?.to_s\n    exporter.headers = headers\n  end\nend\n```\n\nThat is all that you should need to do. If your environment has an appropriate license key\nin the *NEW_RELIC_LICENSE_KEY* environment variable, the OpenTelemetry exporter will send\nthe traces to New Relic. A similar setup should work with any provider that supports OTLP/HTTP\ningest of OpenTelemetry.\n\n## Methods Affected\n\n* ActionController::Router::RouteHandler#process_request\n","summary":"<h1><a id=\"open-telemetryinstrumentationframe-workspider-gazelle\" class=\"anchor\" href=\"#open-telemetryinstrumentationframe-workspider-gazelle\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::FrameWork::SpiderGazelle</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/frameworks/spider-gazelle.cr","line_number":47,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/frameworks/spider-gazelle.cr","line_number":47,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/JGaskinsRedis","path":"OpenTelemetry/InstrumentationDocumentation/JGaskinsRedis.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::JGaskinsRedis","name":"JGaskinsRedis","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/shards/jgaskins_redis.cr","line_number":18,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation"},"doc":"# OpenTelemetry::Instrumentation::JGaskinsRedis\n\n### Instruments\n  * Redis::Connection\n\n### Reference: [https://github.com/jgaskins/redis](https://github.com/jgaskins/redis)\n\nThis instruments the jgaskins Redis shard, which is a simple, pure Crystal shard for\ninteracting with a Redis server. Instrumentation of this shard is accomplished by wrapping\njust a single method.\n\n## Methods Affected\n\n* Redis::Connection#run\n","summary":"<h1><a id=\"open-telemetryinstrumentationj-gaskins-redis\" class=\"anchor\" href=\"#open-telemetryinstrumentationj-gaskins-redis\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::JGaskinsRedis</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/shards/jgaskins_redis.cr","line_number":18,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/shards/jgaskins_redis.cr","line_number":18,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/RethinkDB","path":"OpenTelemetry/InstrumentationDocumentation/RethinkDB.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::RethinkDB","name":"RethinkDB","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/shards/rethinkdb.cr","line_number":30,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation"},"doc":"# OpenTelemetry::Instrumentation::RethinkDB\n\n### Instruments\n  * RethinkDB::Connection\n  * RethinkDB::Connection::ResponseStream\n\n### Reference: [https://github.com/kingsleyh/crystal-rethinkdb](https://github.com/kingsleyh/crystal-rethinkdb)\n\n## Methods Affected\n\n- `RethinkDB::Connection#connect`\n\n  Trace the connection establishment to the database\n\n- `RethinkDB::Connection#authorise`\n\n  Trace authorisation with the database\n\n- `RethinkDB::Connection::ResponseStream#query_term`\n\n  `query_term` sends a ReQL query to the database and reads the response.\n\n- `RethinkDB::Connection::ResponseStream#query_continue`\n\n  `query_continue` follows a `query_term` and is primarily for lazily fetching\n  results from the query curso\n","summary":"<h1><a id=\"open-telemetryinstrumentationrethink-db\" class=\"anchor\" href=\"#open-telemetryinstrumentationrethink-db\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::RethinkDB</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/shards/rethinkdb.cr","line_number":30,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/shards/rethinkdb.cr","line_number":30,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]},{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation/StefanWilleRedis","path":"OpenTelemetry/InstrumentationDocumentation/StefanWilleRedis.html","kind":"struct","full_name":"OpenTelemetry::InstrumentationDocumentation::StefanWilleRedis","name":"StefanWilleRedis","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Struct","kind":"struct","full_name":"Struct","name":"Struct"},{"html_id":"opentelemetry-instrumentation/Value","kind":"struct","full_name":"Value","name":"Value"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/opentelemetry/instrumentation/shards/stefanwille_redis.cr","line_number":29,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"namespace":{"html_id":"opentelemetry-instrumentation/OpenTelemetry/InstrumentationDocumentation","kind":"module","full_name":"OpenTelemetry::InstrumentationDocumentation","name":"InstrumentationDocumentation"},"doc":"# OpenTelemetry::Instrumentation::StefanWilleRedis\n\n### Instruments\n\n* Redis\n* Redis::Connection\n* Redis::Future\n* Redis::Strategy::SingleStatement\n* Redis::Strategy::PauseDuringPipeline\n* Redis::Strategy::PauseDuringTransaction\n* Redis::Strategy::Pipeline\n\n### Reference: [http://stefanwille.github.io/crystal-redis/](http://stefanwille.github.io/crystal-redis/)\n\nDescription of the instrumentation provided, including any nuances, caveats, instructions, or warnings.\n\n## Methods Affected\n\n* Redis#initialize\n* Redis#connect\n* Redis#Future.value=\n* Redis::Strategy::SingleStatement.command\n* Redis::Strategy::PauseDuringPipeline.command\n* Redis::Strategy::PauseDuringTransaction.command\n* Redis::Strategy::Pipeline.command\n","summary":"<h1><a id=\"open-telemetryinstrumentationstefan-wille-redis\" class=\"anchor\" href=\"#open-telemetryinstrumentationstefan-wille-redis\">  <svg class=\"octicon-link\" aria-hidden=\"true\">\n    <use href=\"#octicon-link\"/>\n  </svg>\n</a>OpenTelemetry::Instrumentation::StefanWilleRedis</h1>","constructors":[{"html_id":"new-class-method","name":"new","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/shards/stefanwille_redis.cr","line_number":29,"url":null},"def":{"name":"new","visibility":"Public","body":"x = allocate\nif x.responds_to?(:finalize)\n  ::GC.add_finalizer(x)\nend\nx\n"}}],"instance_methods":[{"html_id":"initialize-instance-method","name":"initialize","abstract":false,"location":{"filename":"src/opentelemetry/instrumentation/shards/stefanwille_redis.cr","line_number":29,"url":null},"def":{"name":"initialize","visibility":"Public","body":""}}]}]}]},{"html_id":"opentelemetry-instrumentation/String","path":"String.html","kind":"class","full_name":"String","name":"String","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/Reference","kind":"class","full_name":"Reference","name":"Reference"},"ancestors":[{"html_id":"opentelemetry-instrumentation/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"},{"html_id":"opentelemetry-instrumentation/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"lib/opentelemetry-api/src/ext/string.cr","line_number":1,"url":null},{"filename":"src/ext/string.cr","line_number":1,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"included_modules":[{"html_id":"opentelemetry-instrumentation/Comparable","kind":"module","full_name":"Comparable","name":"Comparable"}],"doc":"A `String` represents an immutable sequence of UTF-8 characters.\n\nA `String` is typically created with a string literal, enclosing UTF-8 characters\nin double quotes:\n\n```\n\"hello world\"\n```\n\nSee [`String` literals](https://crystal-lang.org/reference/syntax_and_semantics/literals/string.html) in the language reference.\n\nA backslash can be used to denote some characters inside the string:\n\n```\n\"\\\"\" # double quote\n\"\\\\\" # backslash\n\"\\e\" # escape\n\"\\f\" # form feed\n\"\\n\" # newline\n\"\\r\" # carriage return\n\"\\t\" # tab\n\"\\v\" # vertical tab\n```\n\nYou can use a backslash followed by an *u* and four hexadecimal characters to denote a unicode codepoint written:\n\n```\n\"\\u0041\" # == \"A\"\n```\n\nOr you can use curly braces and specify up to six hexadecimal numbers (0 to 10FFFF):\n\n```\n\"\\u{41}\" # == \"A\"\n```\n\nA string can span multiple lines:\n\n```\n\"hello\n      world\" # same as \"hello\\n      world\"\n```\n\nNote that in the above example trailing and leading spaces, as well as newlines,\nend up in the resulting string. To avoid this, you can split a string into multiple lines\nby joining multiple literals with a backslash:\n\n```\n\"hello \" \\\n\"world, \" \\\n\"no newlines\" # same as \"hello world, no newlines\"\n```\n\nAlternatively, a backslash followed by a newline can be inserted inside the string literal:\n\n```\n\"hello \\\n     world, \\\n     no newlines\" # same as \"hello world, no newlines\"\n```\n\nIn this case, leading whitespace is not included in the resulting string.\n\nIf you need to write a string that has many double quotes, parentheses, or similar\ncharacters, you can use alternative literals:\n\n```\n# Supports double quotes and nested parentheses\n%(hello (\"world\")) # same as \"hello (\\\"world\\\")\"\n\n# Supports double quotes and nested brackets\n%[hello [\"world\"]] # same as \"hello [\\\"world\\\"]\"\n\n# Supports double quotes and nested curlies\n%{hello {\"world\"}} # same as \"hello {\\\"world\\\"}\"\n\n# Supports double quotes and nested angles\n%<hello <\"world\">> # same as \"hello <\\\"world\\\">\"\n```\n\nTo create a `String` with embedded expressions, you can use string interpolation:\n\n```\na = 1\nb = 2\n\"sum = #{a + b}\" # \"sum = 3\"\n```\n\nThis ends up invoking `Object#to_s(IO)` on each expression enclosed by `#{...}`.\n\nIf you need to dynamically build a string, use `String#build` or `IO::Memory`.\n\n### Non UTF-8 valid strings\n\nString might end up being conformed of bytes which are an invalid\nbyte sequence according to UTF-8. This can happen if the string is created\nvia one of the constructors that accept bytes, or when getting a string\nfrom `String.build` or `IO::Memory`. No exception will be raised, but\ninvalid byte sequences, when asked as chars, will use the unicode replacement\nchar (value 0xFFFD). For example:\n\n```\n# here 255 is not a valid byte value in the UTF-8 encoding\nstring = String.new(Bytes[255, 97])\nstring.valid_encoding? # => false\n\n# The first char here is the unicode replacement char\nstring.chars # => ['', 'a']\n```\n\nOne can also create strings with specific byte value in them by\nusing octal and hexadecimal escape sequences:\n\n```\n# Octal escape sequences\n\"\\101\" # # => \"A\"\n\"\\12\"  # # => \"\\n\"\n\"\\1\"   # string with one character with code point 1\n\"\\377\" # string with one byte with value 255\n\n# Hexadecimal escape sequences\n\"\\x41\" # # => \"A\"\n\"\\xFF\" # string with one byte with value 255\n```\n\nThe reason for allowing strings that don't have a valid UTF-8 sequence\nis that the world is full of content that isn't properly encoded,\nand having a program raise an exception or stop because of this\nis not good. It's better if programs are more resilient, but\nshow a replacement character when there's an error in incoming data.","summary":"<p>A <code><a href=\"String.html\">String</a></code> represents an immutable sequence of UTF-8 characters.</p>","instance_methods":[{"html_id":"compact-instance-method","name":"compact","doc":"Is this too little to suggest for addition to the stdlib?","summary":"<p>Is this too little to suggest for addition to the stdlib?</p>","abstract":false,"location":{"filename":"src/ext/string.cr","line_number":3,"url":null},"def":{"name":"compact","visibility":"Public","body":"self.strip.gsub(/\\s+/, \" \")"}}]},{"html_id":"opentelemetry-instrumentation/TCPSocket","path":"TCPSocket.html","kind":"class","full_name":"TCPSocket","name":"TCPSocket","abstract":false,"superclass":{"html_id":"opentelemetry-instrumentation/IPSocket","kind":"class","full_name":"IPSocket","name":"IPSocket"},"ancestors":[{"html_id":"opentelemetry-instrumentation/IPSocket","kind":"class","full_name":"IPSocket","name":"IPSocket"},{"html_id":"opentelemetry-instrumentation/Socket","kind":"class","full_name":"Socket","name":"Socket"},{"html_id":"opentelemetry-instrumentation/Crystal/System/Socket","kind":"module","full_name":"Crystal::System::Socket","name":"Socket"},{"html_id":"opentelemetry-instrumentation/IO/Evented","kind":"module","full_name":"IO::Evented","name":"Evented"},{"html_id":"opentelemetry-instrumentation/IO/Buffered","kind":"module","full_name":"IO::Buffered","name":"Buffered"},{"html_id":"opentelemetry-instrumentation/IO","kind":"class","full_name":"IO","name":"IO"},{"html_id":"opentelemetry-instrumentation/Reference","kind":"class","full_name":"Reference","name":"Reference"},{"html_id":"opentelemetry-instrumentation/Object","kind":"class","full_name":"Object","name":"Object"}],"locations":[{"filename":"src/ext/tcpsocket.cr","line_number":3,"url":null}],"repository_name":"opentelemetry-instrumentation","program":false,"enum":false,"alias":false,"const":false,"doc":"A Transmission Control Protocol (TCP/IP) socket.\n\nUsage example:\n```\nrequire \"socket\"\n\nclient = TCPSocket.new(\"localhost\", 1234)\nclient << \"message\\n\"\nresponse = client.gets\nclient.close\n```","summary":"<p>A Transmission Control Protocol (TCP/IP) socket.</p>","constructors":[{"html_id":"new(host,port,dns_timeout=nil,connect_timeout=nil,blocking=false)-class-method","name":"new","doc":"Preserve a hostname, if one is given. Nothing downstream preserves it, and it doesn't\nmake sense to lose that information. Many of the semantic conventions for various types\nof spans really want to have this information.","summary":"<p>Preserve a hostname, if one is given.</p>","abstract":false,"args":[{"name":"host","external_name":"host","restriction":""},{"name":"port","external_name":"port","restriction":""},{"name":"dns_timeout","default_value":"nil","external_name":"dns_timeout","restriction":""},{"name":"connect_timeout","default_value":"nil","external_name":"connect_timeout","restriction":""},{"name":"blocking","default_value":"false","external_name":"blocking","restriction":""}],"args_string":"(host, port, dns_timeout = nil, connect_timeout = nil, blocking = false)","args_html":"(host, port, dns_timeout = <span class=\"n\">nil</span>, connect_timeout = <span class=\"n\">nil</span>, blocking = <span class=\"n\">false</span>)","location":{"filename":"src/ext/tcpsocket.cr","line_number":9,"url":null},"def":{"name":"new","args":[{"name":"host","external_name":"host","restriction":""},{"name":"port","external_name":"port","restriction":""},{"name":"dns_timeout","default_value":"nil","external_name":"dns_timeout","restriction":""},{"name":"connect_timeout","default_value":"nil","external_name":"connect_timeout","restriction":""},{"name":"blocking","default_value":"false","external_name":"blocking","restriction":""}],"visibility":"Public","body":"_ = allocate\n_.initialize(host, port, dns_timeout, connect_timeout, blocking)\nif _.responds_to?(:finalize)\n  ::GC.add_finalizer(_)\nend\n_\n"}}],"instance_methods":[{"html_id":"hostname:String-instance-method","name":"hostname","abstract":false,"location":{"filename":"src/ext/tcpsocket.cr","line_number":4,"url":null},"def":{"name":"hostname","return_type":"String","visibility":"Public","body":"@hostname"}}]}]}})